use quark::{
    openxr::{
        self,
        sys::{ActionSetCreateInfo, Instance, InstanceCreateInfo},
        Entry,
    },
    prelude::*,
    APILayerInstanceData,
};

// put this in your main file!
quark::api_layer! {
    // whatever struct you wanna use for your main instance data
    instance_data: InstanceData,
    // any functions to override, don't forget the destroy functions for everything you add data to!
    override_fns: {
        // <openxr function name>: <rust function name>
        xrCreateActionSet: xr_create_action_set,
        xrDestroyActionSet: xr_destroy_action_set, // generated by the handle macro
        xrCreateAction: create_action
    }
}

#[quark::handle(openxr::sys::Instance)]
pub struct InstanceData {
    instance: openxr::Instance,
}
// this is so we can have the api_layer! macro do all the sensitive work for us and we can goof around :p
impl APILayerInstanceData for InstanceData {
    // you can get the data back from any `Instance` handle by just going `instance.data()?`
    fn create(
        entry: Entry,
        instance_info: &InstanceCreateInfo,
        instance: Instance,
    ) -> XrResult<Self> {
        let app_name = instance_info
            .application_info
            .application_name
            .to_rust_string()?;
        println!("got your new instance chief, app's named {app_name}");
        let instance = unsafe {
            openxr::Instance::from_raw(entry, instance, openxr::InstanceExtensions::default())
        }?;
        Ok(InstanceData { instance })
    }
    // need to give this back for `xrGetInstanceProcAddr`, wanted to avoid a wrapper type that'd complicate stuff
    fn entry(&self) -> &Entry {
        self.instance.entry()
    }
}

#[quark::handle(openxr::sys::ActionSet)]
pub struct ActionSetData {
    instance: openxr::Instance,
    _action_set: openxr::ActionSet, // we gotta store this to keep it alive since we're using openxrs
}

// `wrap_openxr` makes it so you can just make a regular old rust function that lets you use ? wherever and it'll openxrify it
#[quark::wrap_openxr]
// and don't be afraid to swap pointers for borrows, rust allows that and will convert to pointers in the background
// you can also put Option on pointers/borrows if it might be null! but the way this function is, we can implicitly assume that's not true
pub fn xr_create_action_set(
    instance: Instance,
    create_info: &ActionSetCreateInfo,
    original_action_set: &mut openxr::sys::ActionSet,
) -> XrResult {
    // to_rust_string() works on most openxr string types, makes code much much cleaner
    println!(
        "New action set named \"{}\"",
        create_info.localized_action_set_name.to_rust_string()?
    );
    // get the data for a handle, will check if it's valid and everything!
    let data = instance.data()?;
    let name = create_info.action_set_name.to_rust_string()?;
    let localized_name = create_info.localized_action_set_name.to_rust_string()?;

    // using openxrs with the layer undereath's xrGetProcAddr means we can write super nice rust code
    let _action_set =
        data.instance
            .create_action_set(name, localized_name, create_info.priority)?;
    // but we can't forget to set the original! we should use the exact handle it gave us in case the app uses the handle in functions we didn't override
    *original_action_set = _action_set.as_raw();

    // now attach the data to the handle in the registry so we can call `.data()` on the handle later
    original_action_set.add_data(ActionSetData {
        instance: data.instance.clone(),
        _action_set,
    });

    Ok(())
}

#[quark::wrap_openxr]
pub fn create_action(
    action_set: openxr::sys::ActionSet,
    create_info: &openxr::sys::ActionCreateInfo,
    action: &mut openxr::sys::Action,
) -> XrResult {
    println!(
        "Created action with name \"{}\"",
        create_info.localized_action_name.to_rust_string()?
    );
    let instance = &action_set.data()?.instance;
    // if we don't wanna bother with openxrs we can just call the method directly from the function pointers struct then `cvt` to convert a raw openxr result into a rusty one
    cvt(|| unsafe { (instance.fp().create_action)(action_set, create_info, action) })
}
